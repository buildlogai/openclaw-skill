import { z } from 'zod';

// src/schema.ts
var BuildlogFormatSchema = z.enum(["slim", "full"]);
var EditorTypeSchema = z.enum([
  "cursor",
  "vscode",
  "windsurf",
  "zed",
  "neovim",
  "jetbrains",
  "openclaw",
  "other"
]);
var AIProviderSchema = z.enum([
  "claude",
  "gpt",
  "copilot",
  "gemini",
  "other"
]);
var NoteCategorySchema = z.enum([
  "explanation",
  "tip",
  "warning",
  "decision",
  "todo"
]);
var TerminalOutcomeSchema = z.enum([
  "success",
  "failure",
  "partial"
]);
var OutcomeStatusSchema = z.enum([
  "success",
  "partial",
  "failure",
  "abandoned"
]);
var BuildlogAuthorSchema = z.object({
  name: z.string().optional(),
  username: z.string().optional(),
  url: z.string().url().optional()
});
var BaseStepSchema = z.object({
  id: z.string().uuid(),
  timestamp: z.number().nonnegative(),
  sequence: z.number().int().nonnegative()
});
var PromptStepSchema = BaseStepSchema.extend({
  type: z.literal("prompt"),
  content: z.string().min(1),
  context: z.array(z.string()).optional(),
  intent: z.string().optional()
});
var ActionStepSchema = BaseStepSchema.extend({
  type: z.literal("action"),
  summary: z.string().min(1),
  filesCreated: z.array(z.string()).optional(),
  filesModified: z.array(z.string()).optional(),
  filesDeleted: z.array(z.string()).optional(),
  packagesAdded: z.array(z.string()).optional(),
  packagesRemoved: z.array(z.string()).optional(),
  approach: z.string().optional(),
  aiResponse: z.string().optional(),
  diffs: z.record(z.string()).optional()
});
var TerminalStepSchema = BaseStepSchema.extend({
  type: z.literal("terminal"),
  command: z.string().min(1),
  outcome: TerminalOutcomeSchema,
  summary: z.string().optional(),
  output: z.string().optional(),
  exitCode: z.number().int().optional()
});
var NoteStepSchema = BaseStepSchema.extend({
  type: z.literal("note"),
  content: z.string().min(1),
  category: NoteCategorySchema.optional()
});
var CheckpointStepSchema = BaseStepSchema.extend({
  type: z.literal("checkpoint"),
  name: z.string().min(1),
  summary: z.string().min(1)
});
var ErrorStepSchema = BaseStepSchema.extend({
  type: z.literal("error"),
  message: z.string().min(1),
  resolution: z.string().optional(),
  resolved: z.boolean()
});
var BuildlogStepSchema = z.discriminatedUnion("type", [
  PromptStepSchema,
  ActionStepSchema,
  TerminalStepSchema,
  NoteStepSchema,
  CheckpointStepSchema,
  ErrorStepSchema
]);
var BuildlogMetadataSchema = z.object({
  id: z.string().uuid(),
  title: z.string().min(1).max(200),
  description: z.string().max(2e3).optional(),
  author: BuildlogAuthorSchema.optional(),
  createdAt: z.string().datetime(),
  durationSeconds: z.number().int().nonnegative(),
  editor: EditorTypeSchema,
  aiProvider: AIProviderSchema,
  model: z.string().optional(),
  language: z.string().optional(),
  framework: z.string().optional(),
  tags: z.array(z.string().max(50)).max(20).optional(),
  replicable: z.boolean(),
  dependencies: z.array(z.string()).optional()
});
var BuildlogOutcomeSchema = z.object({
  status: OutcomeStatusSchema,
  summary: z.string().min(1),
  filesCreated: z.number().int().nonnegative(),
  filesModified: z.number().int().nonnegative(),
  canReplicate: z.boolean(),
  replicationNotes: z.string().optional()
});
var BuildlogFileSchema = z.object({
  version: z.literal("2.0.0"),
  format: BuildlogFormatSchema,
  metadata: BuildlogMetadataSchema,
  steps: z.array(BuildlogStepSchema),
  outcome: BuildlogOutcomeSchema
});
var BuildlogEventSchema = BuildlogStepSchema;

// src/constants.ts
var BUILDLOG_VERSION = "2.0.0";
var BUILDLOG_DEFAULT_FORMAT = "slim";
var BUILDLOG_MIME_TYPE = "application/vnd.buildlog+json";
var BUILDLOG_EXTENSIONS = [".buildlog", ".vibe"];
var BUILDLOG_DEFAULT_EXTENSION = ".buildlog";
var BUILDLOG_MAX_SLIM_SIZE_BYTES = 100 * 1024;
var BUILDLOG_MAX_FULL_SIZE_BYTES = 50 * 1024 * 1024;
var BUILDLOG_MAX_STEPS = 500;
var BUILDLOG_MAX_TITLE_LENGTH = 200;
var BUILDLOG_MAX_DESCRIPTION_LENGTH = 2e3;
var BUILDLOG_MAX_TAGS = 20;
var BUILDLOG_MAX_TAG_LENGTH = 50;
var BUILDLOG_IGNORE_PATTERNS = [
  "**/node_modules/**",
  "**/.git/**",
  "**/dist/**",
  "**/build/**",
  "**/.next/**",
  "**/.nuxt/**",
  "**/coverage/**",
  "**/*.lock",
  "**/package-lock.json",
  "**/pnpm-lock.yaml",
  "**/yarn.lock",
  "**/*.log",
  "**/.env*",
  "**/*.map",
  "**/.DS_Store",
  "**/Thumbs.db"
];

// src/utils.ts
function isBuildlogFile(filename) {
  const lower = filename.toLowerCase();
  return BUILDLOG_EXTENSIONS.some((ext) => lower.endsWith(ext));
}
function getBuildlogExtension() {
  return ".buildlog";
}
function getBuildlogMimeType() {
  return BUILDLOG_MIME_TYPE;
}
function validateBuildlog(data) {
  const result = BuildlogFileSchema.safeParse(data);
  if (result.success) {
    const buildlog = result.data;
    const warnings = [];
    const jsonSize = JSON.stringify(data).length;
    if (buildlog.format === "slim" && jsonSize > BUILDLOG_MAX_SLIM_SIZE_BYTES) {
      warnings.push({
        path: "format",
        message: `Slim buildlog is ${formatBytes(jsonSize)}, which exceeds the recommended ${formatBytes(BUILDLOG_MAX_SLIM_SIZE_BYTES)} limit`,
        suggestion: "Consider removing full diffs or AI responses, or switch to full format"
      });
    }
    if (buildlog.format === "full" && jsonSize > BUILDLOG_MAX_FULL_SIZE_BYTES) {
      warnings.push({
        path: "format",
        message: `Full buildlog is ${formatBytes(jsonSize)}, which exceeds the recommended ${formatBytes(BUILDLOG_MAX_FULL_SIZE_BYTES)} limit`,
        suggestion: "Consider splitting into multiple buildlogs"
      });
    }
    return { valid: true, warnings: warnings.length > 0 ? warnings : void 0 };
  }
  return {
    valid: false,
    errors: result.error.issues.map((issue) => ({
      path: issue.path.join("."),
      message: issue.message,
      code: issue.code
    }))
  };
}
function parseBuildlog(json) {
  const data = JSON.parse(json);
  const result = BuildlogFileSchema.parse(data);
  return result;
}
function safeParseBuildlog(json) {
  try {
    return parseBuildlog(json);
  } catch {
    return null;
  }
}
function computeStats(buildlog) {
  const stats = {
    format: buildlog.format,
    durationSeconds: buildlog.metadata.durationSeconds,
    stepCount: buildlog.steps.length,
    promptCount: 0,
    actionCount: 0,
    terminalCount: 0,
    noteCount: 0,
    filesCreated: buildlog.outcome.filesCreated,
    filesModified: buildlog.outcome.filesModified,
    isReplicable: buildlog.outcome.canReplicate
  };
  for (const step of buildlog.steps) {
    switch (step.type) {
      case "prompt":
        stats.promptCount++;
        break;
      case "action":
        stats.actionCount++;
        break;
      case "terminal":
        stats.terminalCount++;
        break;
      case "note":
        stats.noteCount++;
        break;
    }
  }
  return stats;
}
function estimateBuildlogSize(buildlog) {
  const jsonSize = JSON.stringify(buildlog).length;
  if (jsonSize < 10 * 1024) return "tiny";
  if (jsonSize < 50 * 1024) return "small";
  if (jsonSize < 500 * 1024) return "medium";
  return "large";
}
function isReplicable(buildlog) {
  const hasPrompts = buildlog.steps.some((s) => s.type === "prompt");
  if (!hasPrompts) return false;
  if (!buildlog.outcome) return false;
  return buildlog.outcome.canReplicate && buildlog.metadata.replicable;
}
function toSlim(buildlog) {
  if (buildlog.format === "slim") {
    return buildlog;
  }
  return {
    ...buildlog,
    format: "slim",
    steps: buildlog.steps.map((step) => {
      if (step.type === "action") {
        const { aiResponse, diffs, ...slimAction } = step;
        return slimAction;
      }
      if (step.type === "terminal") {
        const { output, exitCode, ...slimTerminal } = step;
        return slimTerminal;
      }
      return step;
    })
  };
}
function formatDuration(seconds) {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor(seconds % 3600 / 60);
  const secs = Math.floor(seconds % 60);
  if (hours > 0) {
    return `${hours}h ${minutes}m`;
  }
  if (minutes > 0) {
    return `${minutes}m ${secs}s`;
  }
  return `${secs}s`;
}
function formatDurationClock(seconds) {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor(seconds % 3600 / 60);
  const secs = Math.floor(seconds % 60);
  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
  }
  return `${minutes}:${secs.toString().padStart(2, "0")}`;
}
function formatBytes(bytes) {
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}
function getStepIcon(step) {
  const icons = {
    prompt: "\u{1F4AC}",
    action: "\u26A1",
    terminal: "\u{1F5A5}\uFE0F",
    note: "\u{1F4DD}",
    checkpoint: "\u{1F6A9}",
    error: "\u274C"
  };
  return icons[step.type];
}
function getStepLabel(step) {
  const labels = {
    prompt: "Prompt",
    action: "Action",
    terminal: "Terminal",
    note: "Note",
    checkpoint: "Checkpoint",
    error: "Error"
  };
  return labels[step.type];
}
function detectLanguage(filePath) {
  const ext = filePath.split(".").pop()?.toLowerCase();
  const languageMap = {
    ts: "typescript",
    tsx: "typescript",
    js: "javascript",
    jsx: "javascript",
    mjs: "javascript",
    cjs: "javascript",
    py: "python",
    rb: "ruby",
    go: "go",
    rs: "rust",
    java: "java",
    kt: "kotlin",
    kts: "kotlin",
    swift: "swift",
    cpp: "cpp",
    cc: "cpp",
    cxx: "cpp",
    c: "c",
    h: "c",
    hpp: "cpp",
    cs: "csharp",
    php: "php",
    css: "css",
    scss: "scss",
    sass: "sass",
    less: "less",
    html: "html",
    htm: "html",
    vue: "vue",
    svelte: "svelte",
    json: "json",
    yaml: "yaml",
    yml: "yaml",
    toml: "toml",
    xml: "xml",
    md: "markdown",
    mdx: "markdown",
    sql: "sql",
    sh: "bash",
    bash: "bash",
    zsh: "bash",
    fish: "fish",
    ps1: "powershell",
    dockerfile: "dockerfile",
    makefile: "makefile",
    cmake: "cmake",
    tf: "terraform",
    hcl: "hcl",
    graphql: "graphql",
    gql: "graphql",
    proto: "protobuf",
    r: "r",
    scala: "scala",
    clj: "clojure",
    ex: "elixir",
    exs: "elixir",
    erl: "erlang",
    hs: "haskell",
    lua: "lua",
    pl: "perl",
    dart: "dart",
    nim: "nim",
    zig: "zig",
    v: "v",
    sol: "solidity"
  };
  return languageMap[ext || ""] || "plaintext";
}
function slugify(title) {
  return title.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "").slice(0, 50);
}
var getEventIcon = getStepIcon;
var getEventLabel = getStepLabel;

export { AIProviderSchema, ActionStepSchema, BUILDLOG_DEFAULT_EXTENSION, BUILDLOG_DEFAULT_FORMAT, BUILDLOG_EXTENSIONS, BUILDLOG_IGNORE_PATTERNS, BUILDLOG_MAX_DESCRIPTION_LENGTH, BUILDLOG_MAX_FULL_SIZE_BYTES, BUILDLOG_MAX_SLIM_SIZE_BYTES, BUILDLOG_MAX_STEPS, BUILDLOG_MAX_TAGS, BUILDLOG_MAX_TAG_LENGTH, BUILDLOG_MAX_TITLE_LENGTH, BUILDLOG_MIME_TYPE, BUILDLOG_VERSION, BuildlogAuthorSchema, BuildlogEventSchema, BuildlogFileSchema, BuildlogFormatSchema, BuildlogMetadataSchema, BuildlogOutcomeSchema, BuildlogStepSchema, CheckpointStepSchema, EditorTypeSchema, ErrorStepSchema, NoteCategorySchema, NoteStepSchema, OutcomeStatusSchema, PromptStepSchema, TerminalOutcomeSchema, TerminalStepSchema, computeStats, detectLanguage, estimateBuildlogSize, formatBytes, formatDuration, formatDurationClock, getBuildlogExtension, getBuildlogMimeType, getEventIcon, getEventLabel, getStepIcon, getStepLabel, isBuildlogFile, isReplicable, parseBuildlog, safeParseBuildlog, slugify, toSlim, validateBuildlog };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map